import math
import sys
# IMPORTING ALL THE NECESSERY PYSIDE2 MODULES FOR OUR APPLICATION.
from PyQt5.QtWidgets import *
# MAINWINDOW CODE GENERATED BY THE QT DESIGNER AND pyside2-uic.
import numpy as np
from scipy import signal
import threading
import time
import serial
from collections import deque

# 肌电传感器采样频率
SAMPLEFZ = 10
SAMPRATE = 10
DATASIZE = SAMPLEFZ * 60
PLOTSIZE = SAMPLEFZ * 9
MAXVALUE = 1000

SENSORNUM = 1

# 肌电串口
COM = 'COM4'
# 肌电波特率
EMGBAUD = 9600


# 肌电数据读取
class DataCollect(threading.Thread):
    def __init__(self, dataNo):
        threading.Thread.__init__(self)
        self.dataNo = dataNo
        self.com = "COM5"
        self.baud = 9600
        self.ser = None

        self.data = deque(maxlen=20*DATASIZE)
        self.BOOL = True  # 读取标志位
        self.fatigueTime = None

    def set_com(self, com="COM5"):
        # 端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等
        self.com = com

    def set_baud(self, baud=9600):
        # 波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200
        self.baud = baud

    def get_data(self):
        return list(self.data)

    def run(self):
        # 循环接收数据
        time.sleep(3)
        while self.BOOL:
            if self.ser.in_waiting:
                STRGLO = self.ser.read(self.ser.in_waiting)

                streams = bytes(STRGLO).split(b'\r\n')
                for value in streams:
                    if value:
                        try:
                            self.data.append(float(value))
                        except ValueError:
                            print("EMG Collecting Value Error")

    def DOpenPort(self, timeout):
        # 打开串口
        # 超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）
        # print("肌电串口打开")
        if self.ser is not None and self.ser.is_open:
            return True
        try:
            # 打开串口，并得到串口对象
            self.ser = serial.Serial(self.com, self.baud, timeout=timeout)
            # 判断是否打开成功
            if self.ser.is_open:
                return True
        except Exception as e:
            print("---异常---：", e)
        return False

    # 关闭串口
    def DColsePort(self):
        self.BOOL = False
        self.ser.close()

    # 写串口数据
    # 暂时用不到
    def DWritePort(self, text):
        if not self.ser.is_open:
            return -1
        result = self.ser.write(text.encode("gbk"))  # 写数据
        return result


class Model(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        # self.mode = "DEBUG"
        self.mode = "RELEASE"
        self.collecting = [False] * (SENSORNUM)
        self.recording = [False] * (SENSORNUM)
        self.Flag = True
        self.conn = [DataCollect(i) for i in range(SENSORNUM)]

    def start_collect(self, dataNo, com="COM4", baud=9600):
        if self.collecting[dataNo]:
            self.stop_collect(dataNo)
            return True
        self.conn[dataNo].set_baud(baud)
        self.conn[dataNo].set_com(com)
        ret = self.conn[dataNo].DOpenPort(3)
        if ret:
            self.conn[dataNo].start()
            print("串口" + com + "开启")
            self.collecting[dataNo] = True
            return True
        else:
            print("串口" + com + "读取异常")
            self.collecting[dataNo] = False
            return False

    def stop_collect(self, dataNo):
        self.conn[dataNo].DColsePort()
        self.collecting[dataNo] = False

    def get_data(self, dataNo):
        if self.mode == "RELEASE":
            # return np.zeros(DATASIZE)
            if self.collecting is False:
                return np.zeros(DATASIZE)
            curdata = np.array(self.conn[dataNo].get_data())
            return curdata

        elif self.mode == "DEBUG":
            # cur_time = time.time()
            # data_length = int(cur_time-self.start_time)*6
            data_length = self.index
            self.index += 1
            # data = pd.read_csv('2021_04_22_21-48-39_com3_data.csv')
            # data = data['data']
            if dataNo == 0:
                return self.data0[:data_length]
            else:
                return self.data1[:data_length]

    # 信号滤波
    def get_filtered_signal(self, data):
        emg = []
        if len(data) > 27:
            emg = (data - 0) / (1023 - 0)
            b, a = signal.butter(8, 0.2, 'lowpass')
            emg = signal.filtfilt(b, a, emg)

        return emg if len(emg) > 0 else data

    def stop(self, dataNo):
        self.stop_collect(dataNo)
        self.Flag = False


class Controller(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.models = Model()
        self.flag = False
        time.sleep(1)

    def stop(self):
        self.flag = False

    def startReadingDataA(self, port):
        # 开始采集串口肌电信息
        if not self.models.collecting[0]:
            print("com1:" + port)
            rt = self.models.start_collect(dataNo=0, com=port, baud=EMGBAUD)
            if rt:
                return True
            else:
                return False
        else:
            self.models.stop_collect(dataNo=0)

    def startReadingDataB(self, port):
        if not self.models.collecting[1]:
            # print("com2:" + port)
            rt = self.models.start_collect(dataNo=1, com=port, baud=EMGBAUD)
        else:
            self.models.stop_collect(dataNo=1)

    def run(self):
        time.sleep(2)
        if self.startReadingDataA(COM):
            self.flag = True
        while self.flag:
            time.sleep(0.03)
            # 获取每个传感器信息
            for sensor_i in range(SENSORNUM):
                newdata = self.models.get_data(sensor_i)
                if len(newdata) > 0:
                    print(newdata)

    def stop(self):
        self.flag = False


if __name__ == '__main__':
    app = QApplication(sys.argv)
    logi = Controller()
    logi.start()
    sys.exit(app.exec_())

